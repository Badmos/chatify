const express = require("express");
const favicon = require("serve-favicon");
const app = express();
const http = require("http");
const server = http.Server(app);
const socketIO = require("socket.io");
const path = require("path");
const moment = require("moment")();
const port = process.env.PORT || 5000;

app.use(express.static(path.join(__dirname, "/public"))); //serve static page
app.use(favicon(path.join(__dirname, "/public", "/images", "/favicon.ico"))); //Serve favicon

let io = socketIO(server) //connect app

// create individual users
class User {
    constructor() {
        this.userList = [];
    }
    addUser(id, name, room) {
        let user = { id, name, room };
        this.userList.push(user);
        return user;
    }
    removeUser(id) {
        let user = this.getUser(id);

        if (user) {
            this.userList = this.userList.filter(userInstance => userInstance.id !== id);
        }
        return user
    }
    getUser(id) {
        let user = this.userList.filter(user => user.id === id)[0];
        return user;
    }
    getUserList(room) {
        let roomParticipants = this.userList.filter(user => user.room === room)
        let participantNames = roomParticipants.map(participant => participant.name)
        return participantNames;
    }
}
var roomMembers = new User();

io.on("connection", (socket) => { // run block when client connects to server
    console.log("a user connected");
    socket.on("join", (param, callback) => { // run block when a new user joins a room
        //isValidString returns a bool. It returns true if user data is of str type and is not empty.
        if (!isValidString(param.username) || !isValidString(param.roomName)) {
            // an argument must be passed to the callback for SoketIO to identify it as the error case.
            return callback("Wrong params...")
        }
        callback();
        socket.join(param.roomName) // add room to connection.
        roomMembers.removeUser(socket.id)
        roomMembers.addUser(socket.id, param.username, param.roomName)
        io.to(param.roomName).emit("updatedUserData", roomMembers.getUserList(param.roomName));
        let adminWelcomeMessage = `Hello ${param.username}, 
                        Welcome to the ${param.roomName[0].toUpperCase()}${param.roomName.slice(1).toLowerCase()} group.`
        socket.emit("newMessage", dataHandler("Admin", adminWelcomeMessage));
        //send a 'username joined' message to rooms (except the sender) with thesame ID as the present room
        socket.broadcast.to(param.roomName).emit("newMessage", dataHandler("Admin", `${param.username} joined`))
    });
    // server Listens to message created by client
    socket.on("createMessage", function(returnedData, callback) {
            let user = roomMembers.getUser(socket.id);
            //check user permission and if text is empty
            if (user && isValidString(returnedData.text)) {
                // server processes response from client and sends it back to client
                io.to(user.room).emit("newMessage", dataHandler(user.name, returnedData.text));
            }
            callback("server");
        })
        // server listens to location generated by client
    socket.on("createLocation", function(returnedPosition) {
        let user = roomMembers.getUser(socket.id);
        if (user) {
            // server processes the location it received from client and sends it back to client
            io.to(user.room).emit("newLocation", locationHandler(user.name, returnedPosition.latitude, returnedPosition.longitude,
                `https://www.google.com/maps?q=${returnedPosition.latitude},${returnedPosition.longitude}`));
        }
    });

    socket.on("disconnect", () => { // run block when client  disconnects from server

        //remove user from room
        let user = roomMembers.removeUser(socket.id);
        if (user) {
            io.to(user.room).emit('updatedUserData', roomMembers.getUserList(user.room))
            io.to(user.room).emit('newMessage', dataHandler('Admin', `${user.name} left`))
        }

    });
});


//do string validation
function isValidString(str) {
    return typeof str === "string" && str.trim().length > 0
}

//Handle message data
function dataHandler(from, text) {
    var date = new Date();
    var dateNow = date.getTime();
    return {
        from,
        text,
        createdAt: moment.valueOf()
    }
};

// Handle location message
function locationHandler(from, latitude, longitude, url) {
    var date = moment.valueOf();
    return {
        from,
        latitude,
        longitude,
        url,
        createdAt: date
    }
}
server.listen(port, () => {
    console.log(`listening on port ${port}`);
});